
# Item10 equals는 일반 규약을 지켜 재정의하라
### equals 메소드를 재정의를 권장하지 않는 때
- 각 인스턴스가 본질적으로 고유할 때
	 동작하는 객체를 표현하는 클래스 등
- 인스턴스의 논리적 동치성을 검사할 일이 없을 때
- 상위 클래스에서 재정의한 equals가 하위 클래스에서 들어 맞을 때
- 클래스가 private 이거나 package-private이고 equals 메서드를 호출할 일이 없을 때

논리적 동치성을 확인 해야 하는데 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의 되지 않았을 때 equals 메소드를 재정의 해야 한다

### equals 메서드를 재정의할때 따라야 하는 일반 규약
- 반사성 : a..equals(a) == true
- 대칭성 : a.equals(b) == b..equals(a)
- 추이성 : a.equals(b) == true,  b.equals(c) == true 라면 a.equals(c) == true
	- 구체 클래스를 확장해 새로운 값을 추가하면서 만족시키기 어려움
		상속 대신 컴포지션을 사용해서 우회하는 방법을 사용할 수 있음
- 일관성 : 두 객체가 같다면 앞으로도 같아야함
	- `java.net.URL`의 equals 는 이 규약을 어기었는데 이를 피하기 위해서는 메모리에 존재하는 객체만을 사용한 결정적 계산만 수행하여야함
- null 아님 : 모든 객체가 null과 같지 않아야함
	- `NullPointerException` 을 던지는 것도 이 규약을 어기는 경우 => true를 반환 하여야함
### equals 메소드의 구현시 알면 좋은 것
- 비교하기 복잡한 필드를 가진 클래스는 필드의 표준형을 저장해둔 후 표준형 끼리 비교하면 경제적
- 다를 가능성이 크거나 비교하는 비용이 싼 필드를 먼저 비교한다면 equals의 성능을 높일 수 있음
- 객체의 논리적 상태와 관련 없는 필드는 비교하지 않는 게 좋음
- 단위테스트를 통해 돌려볼것

AutoValue 프래임워크에서는 메서드를 작성해준다

---------------------
# Item11 equals를 재정의 하려거든 hashCode도 재정의하라

### Object 명세에서 의 규약
>equals 비교에 사용되는 정보가 변경되지 않았다면 애플리케이션이 실행 되는 동안 객체의 hash 메서드는 항상 일관되는 값을 반환해야 한다
>equals() 가 두 객체를 같다고 판단 했다면  두 객체의 hashCode 는 같은 값을 반환해야 한다
>equals 가 두 객체를  다르다고 판단 했더라도 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없지만 다른 값을 반환해야 성능이 좋아진다

hashCode 재정의를 잘못했을 때 크게 문제가 되는 부분은 같은 객체는 같은 해시코드를 반환해야 하는 부분이다

### hashCode 메서드 정의할때
- 서로 다른 인스턴스에서 다른 해시코드를 반환하게 한다
- 파생 필드는 계산에서 제외해도 되는데 equals 비교에서 사용되지 않는 필드는 반드시 제외해야한다.
- 해시 충돌이 더 적은 방법이 필요하다면 구아바의 `com.goole.common.hacsh.Hashing` 을 참고하면 좋다. Objects 클래스의 hash 메소드도 해시코드를 계산해주지만 성능이 좋지 않기 때문에 주의
- 불변 클래스에서는 캐싱하는 방식을 고려하는게 좋다
- 성능을 높이기 위해 해시코드를 계산할때 핵심필드를 생략해서는 안된다
	- 해시테이블의 성능을 심각하게 떨어뜨릴수 있다.
- hashCode 생성 규칙을 api 사용자에게 자세히 공표하지 말자

--------------
# Item12 toString을 항상 재정의 하라

### toString의 일반 규약
- 간결하면서 사람이 읽기 쉬운 형태의 유익한 정보를 반환 해야한다
- 모든 하위 클래스에서 이 메서드를 정의하라고 한다

### toString을 재정의 할 때
- toString 잘 구현한 클래스는 사용하기 편하고 디버깅하기 쉽다
- toString은 객체가 가진 주요정보를 모두 반환하는게 좋다
	- 객체가 가진 정보값이 너무 많거나 문자열로 표현하기 어렵다면 요약정보를 담자

### toString 포멧 문서화
##### 포멧을 명시한다면...
- 표준적이고 명확하고 사람이 읽을 수 있는 객체가 된다
- 그 값 그대로 입출력에 사용하거나 CSV 파일처럼 사람이 읽을 수 있는 데이터 객체로 저장가능
- 명시한 포멧에 맞는 문자열과 객체를 상호 전환 할 수 있는 정적팩토리와 생성자를 제공하면 좋음
- 단점 - 포맷을 한번 명시하면 평생 그 포멧에 얽매이게 됨
	- 릴리즈에서 바꾼다면 이를 사용하던 코드와 데이터는 엉망이되기때문
	- 포멧을 문서화 하지 않는다면 유연성을 얻을 수 있음
- 중요한것 의도를 명확하게 밝혀야함


- toString이 반환한 값에 포함된 정보를 얻을 수 있는 api 를 제공 하는것이 좋음
- 그렇지 않으면 정보가 필요할때마다 toString을 파싱해야함


-------------
# Item13 clone 재정의는 주의해서 진행하라
Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 인터페이스지만 목적을 이루지 못함이유
clone 메서드가 선언된곳이 Object 이고 protected 임
그래서 Cloneable을 구현하는 것 만으로는 clone 메서드를 호출 할 수 없음

### Clone 메서드를 잘 동작하게끔 해주는 구현 방법
#### 기존 동작방식
Cloneable 인터페이스는 Object.clone 의 동작 방식을 결정
Cloneable 을 구현한 클래스 
	- 그 객체의 필드를 하나하나 복사한 객체를 반환
Cloneable를 구현 하지 않은 클래스
	-  CloneNotSupportedException 을 반환
Cloneable이 clone 메서드의 동작 방식을 결정
### clone 메서드를 가진 상위 클래스를 상속해 cloneable을 구현하고 싶을 때
super.clone 을 호출
	클래스에 정의된 모든 필드는 원본 필드와 같은 값을 가지는 복제본임
불변 클래스는 clone 메서드를 제공하지 않는 게 좋음
반환할 때는 형변환을 하지 않아도 되게끔 해주자
`try-catch`로 `CloneNotSuppoertedException` 을 처리 해주자 - 일어날 일은 없다
#### 가변 객체를 참조한다면 
clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야함
내부의 구조의 가변 객체를 복사할것
- clone을 재귀적으로 호출해 구현하는 경우
	- stack 의 경우 내부의 elements 배열의 clone을 재귀적으로 호출
	- 만약 elements 필드가 final 이었다면 Cloneable 아키텍쳐는 '가변 객체를 참조하는 필드느 final 로 선언 하라'는 일반적인 용법과 충돌
- 재귀적 호출로는 충분치 않을 때
	- 내부를 순회하며 깊은 복사를 수행
- `super.clone`을 호출하여 얻은 객체의 모든 필드를 초기화 하여 원본객체의 상태를 다시 생성하는 고수준 메서드를 호출
	- 필드 단위 객체 복사를 우회하기 때문에 느리고 Cloneable 아키텍쳐와는 어울리지 않음


##### 그리고...
clone 메서드를 재정의 할때는 throws 절을 없애야함
상속용 클래스는 Cloneable을 구현 해서는 안됨
	- clone 메서드를 퇴하 시키는 것도 방법
복사 생성자와 복사 팩터리라는 객체 복사 방식을 제공하는 것 또한 방법
	- 복사 생성자 : 자신과 같은 클래스의 인스턴스를 인수로 받는 생성자
스레드 안전 클래스를 작성할 때 clone 메서드 동기화를 해주어야한다(item 78)

------
# Item14 Comparable 을 구현할지 고려하라
compareTo는 단수 동치성 비교에 더해 순서까지 비교할 수 있으며 제네릭하다
Comparable을 구현 했다는 것은 그 클래스의 인스턴스들에는 자연적인 순서가 있음을 뜻한다
그래서 이를 구현한 클래스의 배열은 손쉽게 정렬이 가능하다 
뿐만 아니라 이 인터페이스를 활용하는 수많은 제네릭 알고리즘과 컬렉션의 힘을 누릴수 있다.

### 일반 규약
> 이 객체와 주어진 객체의 순서를 비교한다. 이 객체가 주어진 객체보다 작으면 음의정수 같으면 0 크면 양의 정수를 반환하고 비교할수 없는 타입이라면 ClassCastException 을 던진다
> 
> - Comparable을 구현한 클래스는 모든 x, y에 대하여 sgn(x.compareTo(y)) == -sgn(y.compareTo(x))여야 한다. 따라서 x.compareTo(y)는 y.compareTo(x)가 예외를 던질때에 한해 예외를 던져야 한다.
> 	- 두 객체 참조의 순서를 바꾸어 비교해도 예상한 결과가 나와야한다
> 	
>-  Comparable을 구현한 클래스는 추이성을 보장해야 한다. 즉, (x.compareTo(y)>0 && y.compareTo(z) > 0)이면 x.compareTo(z) > 0이다
>	- x가 y 보다 크고 y 가 z 보다 크면 x 는 z 보다 크다
>	
> - Comparable을 구현한 클래스는 모든 z에 대해 x.compareTo(y) == 0이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))이다.
> 	- 크기가 같은 객체 끼리는 어떤 객체와 비교하더라도 항상 같아야함
> 	
> - (x.compareTo(y) == 0) == (x.equals(y))여야 한다. Comparable을 구현하고 이 권고를 지키지 않는 모든 클래스는 그 사실을 명시해야 한다. 
> 		예시 주의: 이 클래스의 순서는 equals 메서드와 일관되지 않다.`

  equals 규약과 동치성 검사 에서 같은 조건을 충족해야하는 것 처럼 주의사항도 같음
  - 기존 클래스를 확장한 구체 클래스에서 새로운 값 컴포넌트를 추가했다면 compareTo 규약을 지킬 방법이 없다, 우회법도 컴포넌트임

### 메서드 작성요령
equals와 비슷한 면이 있음
- compareTo의 메서드의 인수타입은 컴파일타임에 정해짐
	- 타입을 확인 하거나 형변환할 필요가 없음
	- null 이 들어오면 NullPointerException을 던져야함
- 동치인지를 비교하는게 아닌 순서를 비교
	- 비교자를 사용할 수 있는데 비교자는 직접 만들수 있고 자바가 제공해 주기도함
- 핵심 필드가 여러개라면 어느것을 먼저 비교하는지는 중요하다
- 비교 결과가 0이 아니라면 결과를 곧장 반환하자
- 비교자 생성 메서드를 사용하여 메서드 연쇄 방식으로 비교자 생성이 가능함
	- 간결하지만 성능의 저하가 있을 수 있음
- `값의 차`를 기준으로 하는 비교자는 쓰지 말것
	- ex) 해시코드 값의 차를 기준으로 하는 비교자 - 추이성 위반
	- 정수 오버 플로를 일으키거나 오류를 낼 수도있음
