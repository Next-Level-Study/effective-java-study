# Item46 스트림에서는 부작용 없는 함수를 사용하라
### 스트림 패러다임
계산을 일련의 변환으로 재구성
- 각 변환 단계는 가능한 이전 단계의 결과를 받아 처리하는 순수 함수여야한다
	- 순수 함수란 입력만이 결과에 영향을 주는 함수
	- 다른 가변상태를 참조하지 않고 함수 스스로도 다른 상태를 변경하지 않음
	- 이렇게 하기 위해서는 스트림 연산에 건네는 함수 객체에는 부작용(side effect)이 없어야함
forEach 연산은 스트림 계산 결과를 보고 할 때만 사용하고 계산하는데는 사용하지 말자

## Collector
java.util.stream.Collectors
- 스트림을 사용하려면 꼭 배워야 하는 새로운 개념
- 수집기가 생성하는 객체는 일반적으로 컬렉션, 따라서 collector"라는 이름을 씀
- 수집기를 사용하면 스트림의 원소를 손쉽게 컬렉션으로 모을 수 있음
- 수집기 종류 : toList(), toSet(), toCollection() 각각 리스트, 집합, 프로그래머가 지정한 컬렉션 타입 반환

#### 메서드 요약
- toMap()
    - 가장 간단한 형태의 수집기
		- 각 원소가 고유한 키에 매핑되어있을때 적합
	- 더 복잡한 형태는 충돌을 다루는 다양한 전략을 제공
		- 키 매퍼, 값 매퍼는 물론 병합(merge) 함수까지 제공
- groupingBy()
    - 입력으로 분류 함수를 받고, 출력으로는 원소들을 카테고리별로 모아 놓은 맵을 담은 수집기를 반환
- joining()
    - 원소들을 연결하여 문자열을 생성
	    - 구분문자, 접두문자 접미문자를 받을 수 있음

# Item47 반환 타입으로는 스트림보다 컬렉션이 낫다
## 원소 시퀀스
- 일련의 원소를 반환하는 메서드 
- 기본은 컬렉션 인터페이스
- Collection 메서드를 구현할 수 없을 때는 Iterable 인터페이스
- 원소가 기본 타입이거나 성능에 민감하다면 배열
에서 자바 8 이후 스트림의 등장으로 복잡해짐

## 스트림 반환시
스트림은 반복을 지원하지 않음
따라서 반환된 스트림을 for-each로 반복하길 원하는 사용자는 불만이 생김

우회로
- 스트림 반복하기 위한 끔찍한 우회로
```java
for (ProcessHandle ph : (Iterable<ProcessHandle>) ProcessHandle.allProcesses()::iterator) {
            // 프로세스를 처리한다.
}
```

- 난잡하고 직관성이 떨어져 어댑터 메소드를 만들면 상황이 나아진다

```java
public static <E> Iterable<E> iterableOf(Stream<E> stream) { 
	return stream::iterator; 
}

for (ProcessHandle ph : iterableOf(ProcessHandle.allProcesses())) {}
```

## Iterable만 반환하면
스트림 파이프라인으로 처리하고픈 프로그래머가 처리하기 어려움
중계하는 어댑터는 쉽게 구현 가능

>[!info] 결정시
>메서드가 스트림 파이프 라인에서만 쓰일 것을 안다면 스트림을 반환하게 하고 반환된 객체들이 반복문에서만 쓰일 것을 알면 Iterable
>하지만 공개 API를 작성할 대는 둘 모두를 배려해야한다

## Collection 인터페이스
- Iterable의 하위타입이고 stream 메서드도 제공하여 반복화 스트림을 동시에 지원함
- 원소 시퀀스를 반환하는 공개 API의 반환 타입에서느 Collection이나 그 하위 타입을 쓰는게 최선
- 하지만 컬렉션을 반환한다는 이유로 덩치 큰 시퀀스를 메모리에 올려서는 안됨
	- 대신 표현을 간결하게 할 수 있다면 전용 컬렉션을 구현하는 방안을 검토
	- AbstractList를 이용하면 쉽게 구현할 수 있다
	- 위 방식이 어려울 경우 스트림이나 Iterable를 반환하거나 두방식 모두 제공하는 방법이 낫다

>[!결론] 
>Collection 인터페이스를 반환하게 하고 어려울 경우 스트림과 iterable을 사용자를 모두 만족 시킬 수 있도록 하되 한가지 방법의 장점이 뚜렷하다면 그걸 쓰도록하자
> 그리고 어댑터는 코드를 어수선하게 만들고 느리니 직접 구현한 전용 Collection을 사용하자

# Item48 스트림 병렬화는 주의해서 적용하라

>자바로 동시성 프로그램을 작성하기는 쉬워지지만 올바르고 빠르게 작성하는 일은 어렵다
>동시성프로그래밍을 할 때는 안전성과 응답 가능 상태를 유지하기 위해 노력해야한다
>자바8부터 parallel 메서드로 파이프라인을 병렬 실행할 수 있는 스트림을 지원했는데 여기서도 마찬가지이다

### 함부로 parallel을 쓴다면...
12.5초만에 결과가 나오던 코드에서 성능 개선 효과는 커녕 1시간 반이 지나고 강제종료시까지 아무 결과도 출력하지 못했다
- 이유
	- 스트림 라이브러리가 파이프라인을 병렬화 하는 방법을 찾아내기 못했기 때문
#### 병렬화로 성능 개선을 기대할 수 없는 경우
- 데이터 소스가 Stream.iteater
- 중간연산으로 limit를 쓰는 경우

#### 병렬화의 효과가 좋을때
- 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 
- 특징
	- 데이터를 원하는 크기로 정확하고 쉽게 나눌 수 있어 일을 다수의 스레드에 분배하기 좋음
	- 원소들을 순차적으로 실행할때의 참조지역성(메모리에 연속해서 저장)이 뛰어남
	- 참조들이 가리키는 객체가 메모리에서 떨어져 있으면(참조지역성이 낮으면) 메모리로 전송되어 오기를 기다리는 시간이 남음
	- 벌크 연산을 병렬화 할 때 중요한 요소로 작용 가장 좋은 자료 구조는 기본 타입 배열

### 스트림 파이프라인의 종단 연산의 동작방식
- 종단 연산에서 수행하는 작업량이 파이프라인 전체작업에서 상당 비중을 차지하면서 순차적인 연산이라면 병렬수행의 효과는 제한됨
- 가장 적합한 것은 축소
- 축소는 파이프라인에서 만들어진 모둔 원소를 하나로 합치는 작업
	- 가변 축소를 수행하는 Stream의 collect메서드는 병렬화에 적합하지 않음
	- 컬렉션을 합치는 부담이 크기 때문

### 성능
직접 구현한 Stream, Iterable, Collection이 병렬화의 이점을 제대로 누리게 하고 싶다면 결과 스트림의 병렬화 성능을 강도 높게 테스트할것
- 스트림을 잘못 병렬화하면(응답불가를 포함해) 성능이 나빠질 뿐만아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다
- 안전실패 
	- 결과가 잘못되거나 오동작하는것
	- 안전실패는 병렬화한 파이프라인이 사용하는 mappers, filters, 혹은 프로그래머가 제공한 다른 함수 객체가 명세대로 동작하지 않을 때 벌어질 수 있다.
- Stream 명세 엄격한 규약 -> Stream의 reduce 연산에 건네지는 누적기와 결합기 함수는 반드시 결합 법칙을 만족하고, 간섭 받지 않고, 상태를 갖지 않아야 한다.
- 모든 경우를 생각해도 파이프라인이 수행하는 진짜 작업이 병렬화에 드는 추가 비용을 상쇄하지 못하면 성능 향상은 낮을 수 있다
- 스트림 안의 원소수와 원소당 수행되는 코드 줄 수가 수십만은 되어야 성능향상을 맛볼수 있다
- 스트림 병렬화는 오직 성능 최적화 수단임으로 변경 전후로 성능을 테스트하여 병렬화를 사용할 가치가 있는지 확인 해야한다
- 병렬화 조건이 잘 갖춰지면 parallel 메서드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 만끽할 수 있다
