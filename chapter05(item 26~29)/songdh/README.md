# Item 26 로 타입은 사용하지 말라

### 용어
제네릭 클래스/제네릭 인터페이스 -> 제네릭타입 : 클래스와 인터페이스 선언에 타입 매개변수가 쓰이는 것 ex. `List<E>`
매개변수화 타입 : 제네릭 타입에서 정의된 실제타입 매개변수들
로타입 : 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때
	제네릭이 등장하기 전 코드와 호환되도록 하기 위해 사용

### 로타입의 문제점
오류는 가능한 발생 즉시, 컴파일할 때 발견하는 것이 좋은데 로타입은 런타임에야 알수 있음
-> 원인제공 코드가 물리적으로 떨어져 있을 가능성이 커져 에러를 찾기 힘들 때가 있다

### 제네릭의 등장
- 제네릭을 활용하면 정보가 타입 선언 자체에 녹아 엉뚱한 타입의 인스턴스를 삽입시 컴파일 오류가 발생하며 무엇이 잘못됐는지를 정확히 알려준다 
- 컴파일러는 원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가하여 실패하지 않음을 보장한다

로타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 잃게되어 절대로 쓰면 안된다

>List 와` List<Object>` 의 차이
>후자는 괜찮은 이유는 모든 타입을 허용함을 명확히 밝혔기 때문에 괜찮다

### 비한정적 와일드 카드타입
실제 타입 매개변수가 무엇인지 신경쓰고 싶지 않다면 물음표(?)를 사용하자 
`Set<E>`의 비 한정적 와일드 카드 타입은 `Set<?>`이다 
로타입과 비한정적 와일드 카드타입의 차이는 비한정적 와일드 카드타입은 안전하고 로타입은 안전하지 않다
로타입은 아무원소나 넣을 수 있어서 타입 불변식을 훼손하기 쉽다
반면 비한정적 와일드 카드타입으로 선언해두면 null이외의 어떤 원소도 넣을 수 없다 
이렇게 하면 어떤원소도 넣지 못하고 객체의 타입도 알 수 없게 되었다
제약을 받아들일 수 없다면 제네릭 메서드나 한정적 와일드 카드 타입을 사용하며 된다

### 예외
- class 리터럴에는 로타입 사용
- instanceof 연산자
	- 비한정적 와일드 카드 타입 이외의 매개변수화 타입에 적용이 불가능한데 로타입과 비한정적 와일드 카드타입 에서의 instanceof는 완전히 똑같이 동작하므로 깔끔한 로타입을 쓰는게 낫다
# Item 27 비검사 경고를 제거하라

> 할 수 있는 한 모든 비검사 경고를 제거하라 모두 제거하면 타입 안전성이 보장될 것이다

### 경고 제거 방법

제네릭타입 클래스의 오류인 경우 
- 자바 7부터 지원하는 다이아몬드 연산자를 사용하면 컴파일러가 올바른 실제 타입을 추론해서 경고가 사라진다
경고를 제거할 수 없지만 타입 안정하다고 확신하는 경우
- `@SuppressWarnings("unchecked")` 애너테이션을 달아 경고를 숨길 수 있다
	- 가능한 좁은 범위에 적용하자 심각한 경고를 놓칠수있다
	- 에너테이션을 사용할때는 경고를 무시해도 안전한 이유를 주석으로 남겨야하다
		- 수정할 때 타입 안전성을 잃는 상황을 줄여줌
		- 근거를 찾는 중에 안전하지 않은 경우를 찾을 수도 있음

안전하다고 비검사 경고를 두면 새로 진짜 경고가 나와도 눈치채지 못하고 새로운 경고가 파묻힐 수 있다

# Item 28 배열보다는 리스트를 사용하라

배열과 제네릭에는 중요한 차이가 두 가지 있다. 공변(variant)과 실체화(reify)이다.

## 공변
- 배열은 공변(covariant)이다.
    - Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 된다.
    - 공변, 즉 함께 변한다는 뜻이다.
- 반면, 제네릭은 불공변(invariant)이다.
    - 즉, 서로 다른 타입 Type1과 Type2가 있을 때, `List<Type1>`은 `List<Type2>`의 하위 타입도 아니고 상위 타입도 아니다.

```java
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다." // ArrayStoreException을 던진다.

List<Object> objectList = new ArrayList<Long>();
objectList.add("타입이 달라 넣을 수 없다.");
```

- 어느 쪽이든 Long용 저장소에 String을 넣을 수는 없다.
- 다만 배열에서는 그 실수를 런타임에야 알게 되지만, 리스트를 사용하면 컴파일할 때 바로 알 수 있다.

### 실체화

- 배열은 실체화된다.
    - 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.
    - 그래서 Long 배열에 String을 넣으려 하면 ArrayStoreException이 발생하는 것이다.
- 제네릭은 타입 정보가 런타임에는 소거(erasure)된다.
    - 원소 타입을 컴파일에만 검사하며 런타임에는 알 수조차 없다는 뜻이다.

이와 같은 차이로 인해 배열과 제네릭은 잘 어우러지지 못한다.
	- 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다.
	    - `new List<E>[]`, `new List<String[]>`, `new E[]`와 같이 사용하려고 하면 컴파일할 때 제네릭 배열 생성 오류를 일으킨다.

## 제네릭 배열을 만들지 못하는 이유

- 제네릭 배열을 만들 수 있게 되면 배열을 공변이기때문에 타입 안전하지 않다.
- 만약 이를 허용한다면 컴파일러가 자동 생성한 형변환 코드에서 런타임에 ClassCastException이 발생할 수 있다.

## 실체화 불가 타입

- `E`, `List<E>`, `List<String>` 같은 타입을 실체화 불가 타입(non-reifiable type)이라 한다.
    - 이들은 실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입이다.
    - 소거 메커니즘 때문에 매개변수화 타입 가운데 실체화될 수 있는 타입은 `List<?>`와 `Map<?,?>` 같은 비한정적 와일드카드 타입뿐이다.
        - 배열을 비한정적 와일드카드 타입으로 만들 수는 있지만, 유용하게 쓰일 일은 거의 없다.
- 제네릭 컬렉션에서는 자신의 원소 타입을 담은 배열을 반환하는 게 보통은 불가능하다.
- 제네릭 타입과 가변인수 메서드(varargs method)를 함께 쓰면 해석하기 어려운 경고 메시지를 받게 된다.
    - 가변인수 메서드를 호출할 때마다 가변인수 매개변수를 담을 배열이 하나 만들어지는데, 이때 그 배열의 원소가 실체화 불가 타입이라면 경고가 발생하는 것이다.
- 배열로 형변환할 때제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우 대부분은 배열인 `E[]` 대신 컬렉션인 `List<E>`를 사용하면 해결된다.
- 코드가 조금 복잡해지고 성능이 살짝 나빠질 수도 있지만, 대신 타입 안전성과 상호운용성은 좋아진다.


# Item 29 이왕이면 제네릭 타입으로 만들라

JDK가 제공하는 제네릭 타입과 메서드를 사용하는 일은 쉽지만 새로 만드는 일은 조금 어렵다

코드를 제네릭으로 만드는 법
- 클래스 선언에 타입 매개변수를 추가하기
	- 타입 이름으로는 보통 E를 사용한다
- 컴파일 시 하나이상의 오류나 경고가 발생
	- 책의 예시에서는 배열을 실체화  불가타입으로 만들려고 해서 발생
- 해결책 중 하나를 선택하여 해결
	- 1. 제네릭 배열 생성을 금지하는 제약 우회
		- Object 배열을 생성한 다음 제네릭 배열로 형변환
			- 타입 안전하지 않으므로 체크하기
	- 2. 오류가 나는 필드의 타입을 Object[] 로 바꾸기
		- 형변환 경고 발생
- 경고가 발생할시 형변환 오류가 생길 가능성이 있는지 체크하여 `@SuppressWarnings("unchecked)"` 로 경고 숨기기

#### 제네릭 배열 생성을 금지하는 제약 우회
##### 장점 
- 가독성이 좋고 코드가 짧음 
- 형변환을 생성시 한번만 해주면 됨
- 더 선호하고 자주 사용되는 방법

##### 단점
- 배열의 런타임 타입이 컴파일 타임 타입과 달라 힙 오염 발생 

#### 오류가 나는 필드의 타입을 Object[] 로 바꾸기
##### 장점 
힙오염이 생기지 않음
##### 단점 
형변환을 원소를 읽을 때마다 해주어야함

제네릭 타입에서는 리스트를 사용하는 것은 항상 가능하지는 않으므로 이유가 있다면 배열을 쓸 수도 있다

#### 타입 매개변수에 제약을 두는 제네릭 타입
- `List<E extends XXX>`는 XXX의 하위 타입만 받는 다는 뜻 
- 모든 타입은 자기 자신의 하위 타입이므로 `List<XXX>` 도 가능하다
