## 정적 팩토리 메소드
### 장점
 1. 이름을 가질 수 있다
	- 생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 설명하기 어려움(ex. BigInteget(int, int, Random))
	- 정적 팩토리는 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있음(ex. BigInteger.probablePrime)
	- 시그니처가 같은 경우에도 입력 매개변수의 순서를 다르게한 생성자를 추가하는 방식을 사용하는 것보다 각각 정적 팩토리 메소드로 바꾸고 차이를 잘 드러내는 이름을 쓰는 편이 좋다
 2. 호출 될 때 마다 인스턴스를 새로 생성하지는 않아도 된다.
	- 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용 하는 식으로 불필요한 객체 생성을 피할 수 있다.
	- 반복되는 요청에 같은 객체를 반환하는 식으로 인스턴스를 통제 할 수도 있음(인스턴스 통제 클래스)
	> 	인스턴스를 통제 하는 이유
	> 	* 클래스를 싱클턴이나 인스턴스화 불가 아이템으로 만들 수도 있음
	> 	* 불변값 클래스에서 동치인 인스턴스가 하나 뿐임을 보장 가능
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
	- 반환할 객체의 클래스를 자유롭게 선택할 수 있게하는 `엄청난 유연성` 을 줌
		- 구현 클래스를 공개하지 않고도 객체 반환 가능
		- 인터페이스 기반 프레임워크를 만드는 핵심 기술
	- java.util.Collections의 정적 팩토리 메소드에서 45개의 유틸리티의 구현체를 얻을 수 있는데 이 덕분에 API가 작아지고 프로그래머가 익히고 사용하기 쉽게 되었다.
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반활할 수 있다.
	- 반환 타입의 하위타입이면 어떤 클래스의 객체도 반환 가능하다.
		- ex) EnumSet 클래스
			- 원소가 64개 이하 - RegularEnumSet 인스턴스를 반환
			- 원소가 65개 이상 - JumboEnumSet 인스턴스를 반환
			- 하지만 클라이언트는 이 두 클래스의 존재를 몰라도 된다
5. 정적 팩터리 메서드를 작성하는 시점에서는 반환할 객체의 클래스가 존재하지 않아도 된다.
	- 서비스 제공자 프레임워크를 만드는 근간
		- 대표적으로 JDBC가 있음
>			서비스 제공자 프레임워크는 3가지의 핵심 컴포넌트로 이뤄진다.
			1. 서비스 인터페이스(Service Interface): 구현체의 동작을 정의
			2. 제공자 등록 API(Provider Registration API): 제공자가 구현체를 등록할 때 사용
			3. 서비스 접근 API(Service Access API): 클라이언트가 서비스의 인스턴스를 얻을 때 사용
			3개의 핵심 컴포넌트와 더불어 종종 네번째 컴포넌트가 사용되기도 한다.
			1. 서비스 제공자 인터페이스(Service Provider Interface): 서비스 인터페이스의 인스턴스를 생성하는 팩토리 객체를 설명 
		- JDBC의 경우, `DriverManager.registerDriver()`가 프로바이더 등록 API, `DriverManager.getConnection()`이 서비스 액세스 API, 그리고 `Driver`가 서비스 제공자 인터페이스 역할을 한다.

### 단점
1. 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다
	- 생성자가 private라면 상속이 불가능하다
2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
	- 생성자처럼 api 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야한다