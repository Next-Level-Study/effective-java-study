자바에서 제공하는 두 가지 객체 소멸자가 있다 
Finalizer는 예측 불가능하고, 위험할 수 있어 일반적으로 불필요하다.
cleaner는 덜 위험하지만 예예측 불가능하고, 느리고,  일반적으로 불필요하다
따라서 finalizer와 cleaner는 기본적으로 '쓰지 말아야 한다'.

#### 단점
1. 즉시 수행된다는 보장이 없다.
	- finalizer와 cleaner를 수행 속도는 가비지 컬렉터에 달렸으며, 가비지 컬렉터 구현마다 다르다.
2. 자원회수가 지연될 수 있다
	- finalizer 스레드는 다른 애플리케이션 스레드보다 우선 순위가 낮아 실행될 기회를 제대로 얻지 못할 수 있다.
	- cleaner는 자신을 수행할 스레드를 제어할 수는 있지만, 역시나 가비지 컬렉터에 의존하므로 사용하지 않는다.
3. 수행 여부조차 보장하지 않는다.
	- 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존하면 안 된다.
4. 동작 중 발생한 예외가 무시된다.
	- finalizer는 동작 중 발생할 예외를 무시하며, 처리할 작업이 남았더라도 그 순간 종료된다.
5. 심각한 성능문제도 있다
	- finalizer와 cleaner는 가비지 컬렉터의 효율을 떨어트린다.
6. 보안 문제를 일으킬 수 있다.
	- 생성자나 직렬화 과정에서 예외가 발생하면 finalizer가 수행되는데, 이 finalizer를 오버라이딩한 하위클래스의 finalizer가 수행될 수 있다. 심지어, 이 finalizer를 static 필드에 할당하면 가비지 컬렉터에 의해 수거되지도 않는다.
finalizer와 cleaner 를 대신할 방법
파일이나 스레드 등 종료해야 할 자원을 담고 있는 객체의 클래스에서 AutoCloseable을 구현해주고,
클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드를 호출하면 된다.
일반적으로 예외가 발생하면 제대로 종료되도록 try-with-resource 를 사용해야 한다.

#### finalizer와 cleaner의 적절한 역할
1. AutoCloseable을 구현하지 않았을 경우를 대비한 "안전망" 역할.
2. 네이티브 피어와 연결된 객체회수
네이티브 피어: 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체
자바 객체가 아니니 가비지 컬렉터의 gc 대상이 되지 못한다. 
성능 저하를 감당할 수 없거나 즉시 회수해야 한다면 close 를 사용한다.
