# Chater 4. 클래스와 인터페이스

### 4장에서 다루는 내용

- 추상화의 기본 단위인 클래스와 인터페이스 사용법

## 아이템 15 클래스와 멤버의 접근 권한을 최소화 하라

### 정보 은닉, 캡슐화

- 잘 설계된 컴포넌트는 내부 구현과 API를 분리하고, 오직 API를 통해서만 다른 컴포넌트와 소통한다.
- 장점: 컴포넌트를 서로 독립시키며, 개발, 테스트, 최적화, 적용, 분석, 수정을 개별적으로 할 수 있게 한다.
    - 시스템 개발 속도 향상
    - 시스템 관리 비용 저하
    - 성능 최적화에 도움
    - 소프트웨어 재사용 상승
    - 제작 난이도 감소

### 접근 제어 메커니즘

- 클래스, 인터페이스, 멤버의 접근성을 명시한다. → 접근 제한자와 선언된 위치로 정해진다.
- 클래스와 멤버의 접근성은 가능한 한 가장 낮은 접근 수준을 부여해야 한다.
- 톱레벨 클래스와 인터페이스
    - package-private: 내부 구현
    - protected
    - public: API
- 멤버(필드, 메서드, 중첩 클래스, 중첩 인터페이스)
    - private
    - package-private: default
    - protected
    - public
- 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서 보다 좁게 설정할 수 없다. // 리스코프 치환 원칙
    - 인터페이스를 구현하는 클래스는 재정의 메서드를 모두 public으로 선언해야 한다.

1. 코드 테스트를 위해서 클래스의 private 멤버를 package-private까지 풀어주는 것은 허용 가능하다.
2. public 클래스 - 인스턴스 필드는 되도록 public이 아니어야 한다
    - public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.
3. 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.
    - 문제~ 보안 허점 존재
        
        ```jsx
        public static final Thing[] VALUES = {...};
        ```
        
    - public 불변 리스트 활용
        
        ```jsx
        private static final Thing[] PRIVATE_VALUES;
        public static final List<Thing> VALUES = Collections.unmodifiedableList(Arrays.asList(PRIVATE_VALUES));
        ```
        
    - 방어적 복사 방법 활용
        
        ```jsx
        private static final Thing[] PRIVATE_VALUES = {...};
        public static final Thing[] values) {
        	return PRIVATE_VALUES.clone();
        }
        ```
        

## 아이템 16 public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공하여 클래스 내부 표현 방식을 바꿀 수 있는 유연성을 얻자.

package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 문제가 없다.

## 아이템 17 변경 가능성을 최소화하라

### 불변 클래스(invariant class)

- 인스턴스의 내부 값을 수정할 수 없는 클래스이다.
- 생성된 시점의 상태를 파괴될 때까지 간직하는 클래스
- String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal 등

### 클래스를 불변으로 만들기 위한 규칙

- 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다.
    - 하위 클래스에서 부주의하게, 나쁜 의도로 객체의 상태를 변하게 만드는 사태를 막아준다.
- 모든 필드를 final로 선언한다.
    - 새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건네도 문제없이 동작하게끔 보장하는데도 필요하다.
- 모든 필드를 private으로 선언한다.
    - 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아준다.
    - public final로만 선언해도 불변 객체가 되지만, 이렇게 하면 다음 릴리스에서 내부 표현을 바꾸지 못하기에 권하지는 않는다.
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
    - 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 한다.
    - 클라이언트가 제공한 객체 참조를 가리키게 해서는 안 되고접근자 메서드가 그 필드를 그대로 반환해서도 안된다. → 생성자, 접근자(getter), readObject 메서드 모두에서 방어적 복사를 수행해라

### 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요가 없다.

- 여러 스레드가 동시에 사용해도 훼손되지 않는다.
- 불변 객체에 대해서는 어떤 스레드도 다른 스레드에 영향을 줄 수 없어 안심하고 공유할 수 있다.
- → 불변 클래스라면 한 번 만든 인스턴스를 최대한 재활용하자
    - 가장 쉬운 재활용 방법은 자주 쓰이는 값을 상수(public static final)로 제공
        
        ```jsx
        public static final Complex ZERO = new Complex(0, 0);
        ```
        
- 불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리를 제공할 수 있다.
    - 정적 팩터리를 사용하면 메모리 사용량과 가비지 컬렉션 비용이 줄어든다.
- 불변 객체는 방어적 복사(아이템 50)가 필요 없다
    - clone 메서드나 복사 생성자를 제공하지 않는 게 좋다.

### 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.

### 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.

- 값이 바뀌지 않는 구성요소들로 이뤄진 객체라면 구조가 복잡해도 불변식을 유지하기 훨씬 수월하다.
- 맵의 키와 집합의 원소로 안성맞춤이다.

### 불변 객체는 그 자체로 **실패 원자성**을 제공한다. **(아이템 76)**

- 실패 원자성: 메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태여야 한다는 성질
- 상태가 변하지 않으니 불일치 상태에 빠질 가능성이 없다.

### 단점

- 값이 다르면 **반드시** 독립된 객체로 만들어야 한다.
    - 값의 가짓수가 많다면 이들을 모두 만드는 데 큰 비용을 치러야 한다.
    - 백만 비트짜리 BigInteger에서 비트 하나를 바꿔야 한다고 하면
        
        ```jsx
        BigInteger moby = ...;
        // flipbit는 새로운 BigInteger 인스턴스를 생성한다. 
        moby = moby.flipBit(0);
        ```
        
- 해결
    1. 다단계 연산을 예측해서 기본 기능으로 제공
    2. package-private의 가변 동반 클래스를 제공한다.
        1. String - StringBuilder(& 구닥다리 전임자 StringBuffer)

### 불변 클래스 설계 방법

- 클래스가 **불변임을 보장하려면 자신을 상속하지 못하게** 해야 한다.
    1. 가장 쉬운 방법: final 클래스로 선언하기
    2. 모든 생성자를 private 혹은, package-private로 만들고 public 정적 팩터리를 제공하기
        
        ```jsx
        public class Complex{
            private final double re;
            private final double im;
        
            private Complex(double re, double im) {
                this.re = re;
                this.im = iml
            }
        
            public static Complex valueOf(double re,double im) {
                return new Complex(re,im);
            }
        }
        ```
        
        - 바깥에서 볼 수 없는 package-private 구현 클래스를 원하는 만큼 만들어서 활용할 수 있으니 유용하다.

### 정리

- Getter가 있다고 해서 무조건 세터를 만들지는 말자.
    - 클래스는 꼭 필요한 경우가 아니면 불변이어야 한다.
- 모든 클래스를 불변으로 만들 수는 없다.
    - 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.
    - 객체가 가질 수 있는 상태의 수를 줄이면 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다.
    - 변경이 필요한 필드를 뺀 나머지 모두를 final로 선언하자.
- 다른 합당한 이유가 없다면 모든 필드는 private final 이어야 한다.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
    - 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안 된다.
    - 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안 된다.

## 아이템 18 상속보다는 컴포지션을 사용하라

이번 아이템에서 말하는 상속

- 클래스가 다른 클래스를 확장하는 구현 상속을 말한다.
- 이번 아이템에서 논하는 문제는 인터페이스 상속(구현)과는 무관하다.

### 상속은 코드를 재사용하는 강력한 수단이지만 항상 최선은 아니다.

- 잘못 사용하면 오류를 내기 쉽다.
- 상속이 안전한 경우
    - 확장할 목적으로 설계 + 문서화도 잘 된 클래스(아이템 19)
    - 상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안의 상속
- 일반적인 구체 클래스를 패키지 경계를 넘어 다른 패키지의 구체 클래스를 상속하는 일은 위험하다.

### 상속의 문제점

- 메서드 호출(forwarding)과 달리 상속은 캡슐화를 깨뜨린다.
    - 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
    - 메서드 재정의로 인해 하위 클래스는 깨지기 쉽다.
    - 클래스를 확장하더라도 메서드를 재정의하는 대신 새로운 메서드를 추가하는 것도 문제 상황에 부닥친다.

### 해결 - 컴포지션(Composition)

- 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 한다.
- 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 컴포지션(Composition)이라한다.
- 전달(forwarding)과 전달 메서드(forwarding method)
    - 새 클래스의 인스턴스 메세드들은 (private field로 참조하는) 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다.
- 이 방식을 사용하면 새 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나고, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 영향 받지 않는다.

### is-a 와 has-a

- 상속은 반드시 하위 클래스가 상위 클래스의 **진짜 하위 타입인 상황**에서만 쓰여야한다.
- 클래스 A를 상속하는 클래스 B를 작성하려 한다면 B가 정말 A인가, 자문해보자.
- 확신할 수 없다면 상속해서는 안된다. A를 private 인스턴스로 두고, A와는 다른 API를 제공해야 하는 상황이 대다수이다.

### 컴포지션 대신 상속 사용 시 문제점

- 내부 구현을 불필요하게 노출하는 꼴으로, API가 내부 구현에 묶이고 그 클래스의 성능도 영원히 제한된다.
- 클라이언트가 노출된 내부에 직접 접근할 수 있다.
- 클라이언트에서 상위 클래스를 직접 수정하여 하위 클래스의 불변식을 해칠 수 있다.
- 컴포지션 대신 상속을 사용하기로 결정하기 전에 아래 질문을 마지막으로 자문하자.
    - 확장하려는 클래스의 API에 아무런 결함이 없는가?
    - 결함이 있다면 결함이 우리 클래스의 API까지 전파돼도 괜찮은가?
    - 컴포지션으로는 이런 결함을 숨기는 새로운 API를 설계할 수 있지만, 상속은 상위 클래스의 API를 ‘그 결함까지도’ 그대로 승계한다.

## 아이템 19 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

### 상속을 고려한 설계와 문서화

메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다.

- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
- 재정의 가능 메서드: public과 protected 메서드 중 final이 아닌 모든 메서드
- 자기사용으로 호출되는 메서드가 재정의 가능 메서드라면 그 사실을 호출하는 메서드의 API 설명에 적시해야 한다. + 어떤 순서, 어떤 호출 결과로 이어지는지
- 메서드 주석에 @implSpec 태그를 붙여주면 Implementation Requirements 문서를 자바독 도구가 생성해준다.
    
    

효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별해하여 protected 메서드 형태로 공개해야 할 수도 있다.

- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.
- 꼭 필요한 protected 멤버를 놓치면 하위 클래스를 작성할 때 빈자리가 드러난다.
- 하위 클래스를 여러 개 만들 때까지 전혀 쓰이지 않는 protected 멤버는 private에 있어야 할 가능성이 크다.

상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.

### 상속을 허용하는 클래스가 지켜야 하는 제약

상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.

- 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다.
- private, final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 된다.

Cloneable과 Serializable 인터페이스를 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않은 생각이다.

- clone과, readObject 메서드는 생성자와 비슷하게 새로운 객체를 만든다.
- clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.
    - readObject의 경우 하위 클래스의 상태가 역직렬화되기 전에 재정의한 메서드부터 호출하게 된다.
    - clone의 경우 하위 클래스의 clone 메서드가 복제본의 상태를 수정하기 전에 재정의한 메서드를 호출한다.
- Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 이 메서드들은 protected로 선언해야 한다.
    - private으로 선언하면 하위 클래스에서 무시되기 때문이다.

### **상속용으로 설계하지 않는 클래스는 상속을 금지하자.**

- 클래스를 final로 선언
- 모든 생성자를 private이나 package-private로 선언하고 public 정적 팩토리 만들기
- 아이템 18에서 설명한 래퍼 클래스 패턴(컴포지션)

## 아이템 20 추상 클래스보다는 인터페이스를 우선하라

자바가 제공하는 다중 구현 메커니즘: 인터페이스, 추상 클래스

- 둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다.
- 자바는 단일 상속만 지원하니 추상 클래스 방식은 새로운 타입을 정의하는 데 제약이 있다.
- 인터페이스가 선언한 메서드를 모두 정의하고 규약을 잘 지킨 클래스 면 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.

### 인터페이스를 우선해야 하는 이유

기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있다.

- 반면 기존 클래스 위에 새로운 추상 클래스를 넣기는 어렵다.
- 만일 두 클래스가 같은 추상 클래스를 확장하길 원한다면, 추상 클래스는 계층 구조상 두 클래스의 공통 조상이어야 한다.

인터페이스는 믹스인 정의에 안성맞춤이다.

- 믹스인(mixin): 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 주된 타입 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.
- 예) Comparable은 자신을 구현할 클래스의 인스턴스들끼리는 순서를 정할 수 있다고 선언하는 믹스인 인터페이스이다.

인터페이스로는 계층 구조가 없는 타입 프레임워크를 만들 수 있다.

- 타입을 계층적으로 정의하면 개념을 구조적으로 표현할 수 있지만, 현실에는 계층을 엄격히 구분하기 어려운 개념도 있다.

```jsx
public interface Singer {
    AudioClip sing(Song s);
}

public interface Songwriter {
    Song compose(int charPosition);
}
```

- 이러한 코드처럼 타입을 인터페이스로 정의하면 가수 클래스가 Singer, Songwriter 모두를 구현해도 문제가 되지 않는다.
- 같은 구조를 클래스로 만들려면 조합 폭발(combinatiorial explosion)이 발생할 수도 있다.

래퍼 클래스 관용구(아이템 18)와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.

- 타입을 추상 클래스로 정의해두면 그 타입에 기능을 추가하는 방법은 상속뿐이다.
- 상속해서 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기는 더 쉽다.

### 인터페이스와 추상 클래스의 장점을 모두 취하는 방법

인터페이스와 추상 골격 구현 클래스(skeletal implementation class)를 함께 제공하는 방법으로, 인터페이스로는 타입을 정의하고, 필요하면 디폴트 메서드도 제공한다. // 템플릿 메서드 패턴

- 인터페이스 이름이 Interface라면 골격 구현 클래스의 이름은 AbstractInterface로 짓는다.
- AbstractCollection, AbstractSet, AbstractList, AbstractMap이 핵심 컬렉션 인터페이스의 골격 구현이다.

### 골격 구현 클래스의 장점

추상 클래스처럼 구현을 도와주는 동시에, 추상 클래스로 타입을 정의할 때 따라오는 제약에서는 자유롭다는 점에 있다.

- 골격 구현 클래스를 우회적으로 이용할 수도 있다.
- 인터페이스를 구현한 클래스에서 해당 골격 구현을 확장한 private 내부 클래스를 정의하고, 각 메서드 호출을 내부 클래스의 인스턴스에 전달하는 것이다.

### 골격 구현 작성

1. 인터페이스를 잘 살펴 다른 메서들의 구현에 사용되는 기반 메서드 선정한다.
    1. 이러한 기반 메서드는 골격 구현에서는 추상 메서드가 된다.
2. 기반 메서드들을 사용해 직접 구현할 수 있는 메서드를 모두 디폴트 메서드로 제공한다.
    1. equals, hashCode 같은 Object 메서드는 제공하면 안 된다.
    2. 인터페이스의 메서드 모두가 기반 메서드와 디폴트 메서드가 된다면 골격 구현 클래스를 별도로 만들지 않아도 된다.
    3. 기반 메서드나 디폴트 메서드로 만들지 못한 메서드가 남아 있으면 인터페이스를 구현하는 골격 구현 클래스를 하나 만들어서 남은 메서드들을 작성해서 넣는다.
    4. 골격 구현 클래스에는 필요하면 public이 아닌 필드와 메서드를 추가해도 된다.
