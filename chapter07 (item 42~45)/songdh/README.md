# Item42 익명 클래스보다는 람다를 사용하라
## 익명 클래스
자바에서 함수 타입을 표현할 때 추상메서드를 하나만 담은 인터페이스를 사용했는데 이런 인터페이스의 인스턴스를 함수 객체라고 하여 특정 함수나 동작을 나타내는데 사용했다 
jdk 1.1 등장 이후 함수 객체를 만드는 주요수단은 익명 클래스([Item24](../4장%20클래스와%20인터페이스/Item24%20멤버%20클래스는%20되도록%20static으로%20만들라.md))가 되었다
함수 객체를 사용하는 과거 객체 지향 디자인 패턴에는 익명 클래스면 충분했지만 함수형 프로그래밍에서는 코드가 너무 길기 때문에 적합하지 않았다
## 람다
함수형 인터페이스라고 부르는 이 인터페이스의 인스턴스를 람다식을 사용해 만들 수 있게 되었다
#### 장점
- 람다는 함수나 익명 클래스와 개념은 비슷하지만 코드는 훨씬 간결하다
- 어떤 동작을 하는지가 명확하게 드러난다
- 람다 매개변수와 반환값의 타입은 컴파일러가 추론해준다
	- 추론하지 못할때는 직접 명시해야한다
	- 타입을 알 수 없다는 오류가 발생할때를 제외하고는 모든 매개변수의 타입은 생략하는게 좋다
- 람다를 언어 차원에서 지원하면서 기존에는 적합하지 않았던 곳에서도 함수 객체를 실용적으로 사용가능하게 되었다
#### 단점
- 람다는 이름이 없고 문서화를 하지 못한다
- 람다가 3줄이상 넘어가 길거나 읽기 어렵다면 더 간단히 줄여보거나 람다를 쓰지 않느 쪽으로 리팩터링 하는게 좋다

#### 람다로 대체할 수 없는 것
- 추상 클래스의 인스턴스를 만들때
	- 람다를 쓸 수 없어 익명 클래스를 써야한다
	- 추상 메서드가 여러개인 인터페이스의 인스턴스를 만들때도 익명클래스를 쓸 수 있다
- 람다는 자신을참조할 수 없다
	- 람다에서의 this 키워드는 바깥 인스턴스를 가리킨다
	- 익명클래스에서의 this는 익명클래스의 인스턴스 자신을 가리킨다 그래서 함수 객체가 자신을 참조해야한다면 반드시 익명 클래스를 써야함

람다도 직렬화 형태가 구현별로 다를 수 있어서 람다를 직렬화 하는 일은 삼가야한다(익명클래스도 마찬가지) 직렬화해야만 하는 함수 객체가 있다면 private 정적 중첩 클래스의 인스턴스를사용하자[Item24](../4장%20클래스와%20인터페이스/Item24%20멤버%20클래스는%20되도록%20static으로%20만들라.md)
# Item43 람다보다는 메서드 참조를 사용하라
## 메서드참조
람다를 더 간결하게 만드는 방법
람다 대신 메서드의 참조를 전달하면 똑같은 결과를 더 보기 좋게 얻을 수 있다
매개변수의 수가 늘어날수록 메서드 참조로 제거할 수 있는 코드의 양도 늘어난다
- 매개변수의 이름이 프로그래머에게 좋은 가이드가 되는 경우 길이가 길어도 읽기 쉽고 유지보수도 쉬울수 있기때문에 람다를 쓰는게 나을때도 있다
람다로 할수 없는 일이라면 메서드 참조로도 할 수 없다
- 예외 제네릭 함수타입 구현
	- 제네릭 람다식이라는 문법이 존재하지 않기때문

메서드 참조를 사용하는 편이 보통은 더 짧고 간결하므로 람다로 구현했을 때 너무 길거나 복잡하다면 메서드 참조가 종은 대안이 되어준다
람다로 작성할 코드를 새로운 메서드에 담은 다음 람다 대신 그 메서드 참조를 사용하는 식

### 람다가 메서드 참조보다 간단할 때
-  주로 메서드와 람다가 같은 클래스에 있을때
	`service.execuet(이런저런클래스입니다::action);`
	람다로 대체하면 `service.execute(() -> action());`
	짧고 명확하다
	Funtion.identity() 보다는 (x -> x)를 사용하는 게 좋을 때도 있다

### 메서드 참조의 유형
| 메서드 참조 유형                | 설명                                                                                                                                                                                                         | 예                     | 같은 기능을 하는 람다                                  |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------- | ------------------------------------------------------ |
| 정적                            |                                                                                                                                                                                                              | `Integer::parseInt`    | `str -> Integer.parseInt(str)`                         |
| 한정적 인스턴스 메서드르 참조   | 근본적으로 정적 참조와 비슷<br>함수 객체가 받는 인수와 참조되는 메서드가 받는 인수가 똑같음                                                                                                                  | `Instant.now::isAfter` | Instant then = Instant.now(); <br>t -> then.isAfter(t) |
| 비한정적 인스턴스 메서드르 참조 | 함수 객체를 적용하는 시점에 수신객체를 알려줌<br>수신객체 전달용 매개변수가 매개변수 목록의 첫 번째로 추가 그대로 메서드 선언에 정의된 매개변수가 따름<br>주로 스트림 파이프라인에서의 매핑과 필터함수에 쓰임 | `String::toLowerCase`  | `str -> str.toLowerCase()`                             |
| 클래스 생성자                   | 팩터리 객체로 사용                                                                                                                                                                                                             | `TreeMap<K, V>::new`   | `() -> new TreeMap<K, V>()`                            |
| 배열 생성자                     |                                                                                                                                                                                                              | int[]::new             | len -> new int[len]                                    |
# Item44 표준 함수형 인터페이스를 사용하라
자바가 람다를 지원하면서 탬플릿 메서드 패턴의 매력이 줄어들고 함수객체를 받는 정적패터리다 생성자를 제공하는 방식으로 변화하였다
따라서 함수 객체를 매개변수로 받는 생성자와 메서드를 더 많이 만들어야한다

## 표준 함수형 인터페이스
자바 표준 라이브러리의 java.util.funcion 패키지에 다양한 용도로 사용할 수 있게 구현 되어있음 
적합한게 있다면 직접 구현하지 말고 표준 함수형 인터페이스를 활용하면 API가 다루는 개념의 수가 줄어 익히기 쉬워짐
- 유용한 디폴트 메서드를 만이 제공하여 다른 코드와의 상호 운용성도 크게 좋아짐
- 43개의 인터페이스가 담겨있음
	- 다 외울 필요 없이 기본 적인 규칙이 정해져 있으니 기본 규칙만 기억해두자
### 기본 함수형 인터페이스 정리 표
|인터페이스|함수 시그니처|의미|예|
|---|---|---|---|
|`UnaryOperator<T>`|`T apply(T t)`|반환 값과 인수의 타입이 같은 함수, 인수는 1개|`String::toLowerCase`|
|`BinaryOperator<T>`|`T apply(T t1, T t2)`|반환 값과 인수의 타입이 같은 함수, 인수는 2개|`BigInteger::add`|
|`Predicate<T>`|`boolean test(T t)`|인수 하나를 받아 boolean을 반환하는 함수|`Collection::isEmpty`|
|`Function<T, R>`|`R apply(T t)`|인수와 반환 타입이 다른 함수|`Arrays::asList`|
|`Supplier<T>`|`T get()`|인수를 받지 않고 값을 반환(혹은 제공)하는 함수|`Instant::now`|
|`Consumer<T>`|`void accept(T t)`|인수 하나 받고 반환 값은 없는 함수|`System.out::println`|
- 표준 함수형 인터페이스 대부분은 기본 타입(int, long, double)만 지원
	- 박싱된 기본 타입을 넣어 사용하지는 말자. 계산량이 많을 때는 성능이 처참히 느려질 수 있고 "박싱된 기본 타입 대신 기본 타입을 사용하라"라는 아이템 61의 조언을 위배함

### 같은 표준 함수형 인터페이스가 존재해도 직접 작성해야할때
1. 자주 쓰이며, 이름 자체가 용도를 명확히 설명해주는 경우
2. 반드시 따라야하는 규약이 있는 경우
3. 유용한 디폴트 메서드를 제공할 수 있는 경우
대표적인 예시가 `Comparator<T>` 메소드 이다
## @FunctionalInterface 애너테이션
직접 만든 함수형 인테페이스엔 항상 쓸 것
#### @FuncionalInterface의 세 가지 목적
1. 해당 클래스의 코드나 설명 문서를 읽을 이에게 그 인터페이스가 람다용으로 설계된 것임을 알려준다.
2. 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
3. 그 결과 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아준다.

>[!attention] 주의
>전용 함수형 인터페이스를 작성하기로 했다면 자신이 작성하는게 **'인터페이스'** 임을 명심하고 주의해서 설계할 것!
> 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중정의(Overloading)해서는 안된다. 클라이언트에게 불필요한 모호함만 안겨줄 뿐이며, 이 모호함으로 인해 실제로 문제가 일어나기도 한다.


# Item45 스트림은 주의해서 사용하라
## 스트림 API
- 다량의 데이터 처리작업을 돕고자 자바8에 추가되었다
- 추상 개념 중 핵심
	1. 스트림은 데이터원소의 유한 혹은 무한 시퀀스(sequence)를 뜻함
	2. 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현하는 개념
- 스트림의 원소는 컬랙션, 배열,파일, 다른 스트림등 어디로부터든 올 수 있다
- 스트림 안의 데이터 원소들은 객체 참조나 기본타입(int, long, double)값
### 스트림 파이프라인
소스스트림 -> 중간연산(하나이상) -> 종단연산으로 이루어진다
- 스트림 파이프라인은 순차적으로 실행
	- 병렬로 실행하고자 하면 parallel메서드를 호출하면 됨
- 스트림을 과용하면 프로그램이 읽거나 유지보수하기 어려워짐
- char용 스트림은 지원하지 않음
	- 사용한다면 형변환을 명시적으로 해줘야한다
	- 하지만 삼가는 편이 더 좋음!
- 종단연산이 없는 스트림 파이프라인은 아무일도 하지 않는 명령어와 같다

#### 중간연산
- 스트림을 어떠한 방식으로 변환한다
- 원소에 함수를 적용하거나 특정 조건을 만족 못하는 원소를 걸러낼 수 잇다
- 한 스트림을 다른 스트림으로 변환
#### 종단연산
- 마지막 중간연산이 내놓은 스트림에 최후의 연산을 가함
#### 지연평가
- 스트림 파이프라인은 지연 평가됨
- 평가는 종단연산이 호출될 때 이뤄지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다
#### 플루언트 API
- 메서드 연쇄를 지원
- 파이프라인 하나를 구성하는 모든 호출을 연결하여 단하나의 표현식으로 완성 가능
- 파이프라인 여러개를 연결하여 표현식 하나로 만들 수도 있음

>[!info] 
>람다의 매개변수 이름은 주의해서 정하자
>람다에서는 타입이름을 자주 생략하므로 매개변수 이름을 잘 지어야 스트림 파이프라인의 가독성이 유지된다
>도우미 메서드를 적절히 활용하는 일 또한 스트림 파이프라인에서 훨씬 중요하다


## 리팩토링 할 때
- 기존 코드는 스트림을 사용하도록 리팩터링하되, 새 코드가 더 나아 보일 때만 반영하자

#### 함수 블록에서는 할 수 없지만 코드 블록으로 할 수 있는 일
- 코드 블록에서는 범위 안의 지역변수를 읽고 수정할 수 있지만, 람다에서는 final이거나 사실상 final 변수만 가능하며 지역 변수를 수정하는 건 불가능하다.
- 코드 블록에서는 return문으로 메서드에서 빠져나가거나, break, continue로 반복문을 제어하거나 검사예외를 던질 수 있지만, 람다는 할수가 없다.
#### 스트림이 알맞는 상황
- 원소들의 시퀀스를 일관되게 변환한다.
- 원소들의 시퀀스를 필터링한다.
- 원소들의 시퀀스를 하나의 연산을 사용해 결합한다.(더하기 연결하기 최솟값구하기)
- 원소들의 시퀀스를 컬렉션에 모은다
- 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.

#### 스트림으로 처리하기 어려운 일
- 한 데이터가 파이프라인의 여러 단계를 통과할 때 이 데이터의 각 단계에서의 값들에 동시 접근하기 어려운 경우
	- 다른 값에 매핑하고 나면 원래의 값은 잃는 구조이기 때문이다.
	- 원래 값과 새로운 값의 쌍을 저장하는 객체를 사용해 매핑하는 우회 방법도 있지만, 복잡하기 떄문에 사용하지 않는 경우가 좋다,
#### 스트림 vs 반복문
- 결국 개인 취향과 프로그래밍 환경의 문제
- 확신이 서지않을때는 for문 스트림방식이 나아보이고 동료가 스트림 코드를 이해할 수 있고 선호한다면 스트림 방식
- 둘다 해보고 더 나은 쪽을 선택하는것도 좋음
